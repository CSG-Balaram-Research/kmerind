buffered iterator?

read struct: for fastQ, for fastA.
	fastQ - okay.
	fastA - ??
	
	use MPI-IO

count number of reads - every 4 lines
	indexing iterator (return positions in underlying iterator)
	and get the counts

	or create data that indexes and get the counts:  okay.

iterator with element type of iterator (for fasta?)
	essentially done via read struct.

iterator with element type of reads.
	internal to reads are 2 ptrs/iterators
	
	done.

(
iterator of iterator? with delimiter
	internal iterator has a delimiter for termination
		== search in outer iterator during the ++ phase.
	outer iterator uses a different delimiter
	internal pointers of both are incremented together
	
	essentially done.
)
	

assign read ids. (prefix scan)
	done.
	use global offset in file -> no need for communication therefore no need to read 2x.
		set in functor constructor
		done.  this means nothing needs to be kept in memory.
	use simpler iterator to search for number of records - fast but bad estimate.
		

create kmers and reverse complement - abyss idea is not bad
	buffer in transformer.
		need to update buffer during operator++()
		functor has increment and retrieve op
			done.
	reverse complement.
			done.
	
	abyss idea extended:  kmer, first half xor with reverse complement of second half.  leave second half as is.
		first part now has the symmetry.  second half allows reconstruct
		may be usable as keys for storing quality scores.
	  change in distribution?
	  	yes.  00 occurs from AA, CC, GG, TT; 01 from AC, CA, GT, TG;
	  		10 from AG, GA, CT, TC; 11 from AT, CG, GC, TA.
	  		if p(A) = p(T) = x, p(C) = p(G) = 0.5-x,
	  		
	  		then p(00) = p(11) = 4x^2 - 2x + 0.5; p(01) = p(10) = 2x - 4x^2, quadratic functions.
	  		
	  		could this create an imbalance for a region of the kmer space?
	  		 	no.  actually more even.
	
create quality score quality score
	reverse complement has same score.
	
	a simple iteration is done that computes the "Phred Score" for a kmer accurately.

generalization of iterator patterns
	1. transform iterator (1 to 1.  memory of output)
	2. filter iterator (searching.  ? to 1)
	3. buffered transform iterator (searching. ? to 1)
		ascii -> read struct
			can we get more operation inside here?
	4. buffered transform iterator (1 to 1 with memory of m previous inputs.  )
		ascii -> kmer
		quality scoring
	5. m to 1 transform iterator.  (buffered transform iterator?.  mem of output)
		packing
	6. m to n transform iterator
		unpacking (1 to n)
		packed->kmer (m to n)
		
	2..6 need to know end of iterator
	which supports what type of base iterator?
	

mpi redistribution code.
	threading and support for streaming.	
	at least 1 thread per process for managing file input
	at least 1 thread per process for managing MPI input
	compute threads independently compute and do MPI-isend?
	
	global array - no global algorithms to go with it
	non-collective communication is good - reduce network congestion
	async communication is good - overalp compute and io
	
	semantic is still to send a block, and receive a block and do something
	send - into a sink.  iterator or buffer?
	receive - read from a src as a whole block then do someting about it - iterator or buffer?
	
	local sorting as merge operation after communication to hide sorting?


query...


random sequence generator

// support queries for read id, read positions, and count


spaced seeds?

OpenMP version
test remote file open.
FASTA

