// include google test
#include <gtest/gtest.h>

// include classes to test
#include <common/Kmer.hpp>

// templated test function
template<typename kmer_word_type, typename input_word_type, unsigned int kmer_size=31, unsigned int bits_per_char=2>
void test_kmer_with_word_type(input_word_type* kmer_data, uint64_t* kmer_ex) {

  typedef typename bliss::Kmer<kmer_size, bits_per_char, kmer_word_type> kmer_type;

  // create (fill) Kmer
  kmer_type kmer;

  input_word_type* kmer_pointer = kmer_data;
  // fill first kmer
  kmer.fillFromPaddedStream(kmer_pointer);
  kmer_type kmer_ex_0(reinterpret_cast<kmer_word_type*>(kmer_ex));
  EXPECT_EQ(kmer, kmer_ex_0) << "Kmer from stream should be equal to kmer from non-stream";

  // get offset
  const unsigned int kmer_bits = kmer_size * bits_per_char;
  unsigned int offset = kmer_bits % (sizeof(input_word_type)*8);
  kmer_pointer += kmer_bits / (sizeof(input_word_type)*8);


  unsigned int step_factor = bits_per_char / 2;

  // generate more kmers
  for (unsigned int i = step_factor; i < 25; i += step_factor)
  {
    kmer.nextKmerFromPaddedStream(kmer_pointer, offset);
    kmer_type kmer_ex_i(reinterpret_cast<kmer_word_type*>(kmer_ex+i));
    EXPECT_EQ(kmer_ex_i, kmer) << "Kmer compare unequal for sizeof(input)="<< sizeof(input_word_type) << ", sizeof(kmer_word)=" << sizeof(kmer_word_type) << ", size=" << kmer_size << ", bits=" << bits_per_char << " i = " << i;
  }
}


template<typename input_word_type, unsigned int kmer_size=31, unsigned int bits_per_char=2>
void test_kmers_with_input_type(input_word_type* kmer_data, uint64_t* kmer_ex)
{

  test_kmer_with_word_type<uint8_t,  input_word_type, kmer_size, bits_per_char>(reinterpret_cast<input_word_type*>(kmer_data), kmer_ex);
  test_kmer_with_word_type<uint16_t, input_word_type, kmer_size, bits_per_char>(reinterpret_cast<input_word_type*>(kmer_data), kmer_ex);
  test_kmer_with_word_type<uint32_t, input_word_type, kmer_size, bits_per_char>(reinterpret_cast<input_word_type*>(kmer_data), kmer_ex);
  test_kmer_with_word_type<uint64_t, input_word_type, kmer_size, bits_per_char>(reinterpret_cast<input_word_type*>(kmer_data), kmer_ex);
}

template<typename input_word_type>
void test_kmers(input_word_type* kmer_data, uint64_t* kmer_ex)
{
  // test for bits per character: 2, 4, and 8 (no padding only!)
  test_kmers_with_input_type<input_word_type, 31, 2>(kmer_data, kmer_ex);
  test_kmers_with_input_type<input_word_type, 28, 2>(kmer_data, kmer_ex);
  test_kmers_with_input_type<input_word_type, 13, 2>(kmer_data, kmer_ex);
  test_kmers_with_input_type<input_word_type, 4, 2>(kmer_data, kmer_ex);
  test_kmers_with_input_type<input_word_type, 1, 2>(kmer_data, kmer_ex);

  test_kmers_with_input_type<input_word_type, 10, 4>(kmer_data, kmer_ex);
  test_kmers_with_input_type<input_word_type, 13, 4>(kmer_data, kmer_ex);

  test_kmers_with_input_type<input_word_type, 7, 8>(kmer_data, kmer_ex);
  test_kmers_with_input_type<input_word_type, 5, 8>(kmer_data, kmer_ex);

}


TEST(KmerGeneration, TestKmerGenerationUnpadded)
{
  // test sequence: 0xabba56781234deadbeef01c0ffee

  // expected kmers:
  // generated by the python commands (thank you python for integrated bigints)
  /*
   * val = 0xabba56781234deadbeef01c0ffee
   * print(",\n".join([" "*24 + "0x" + hex(val >> 2*i)[-16:] for i in range(0,25)]))
   */
  uint64_t kmer_ex[25] = {0xdeadbeef01c0ffee,
                          0x37ab6fbbc0703ffb,
                          0x4deadbeef01c0ffe,
                          0xd37ab6fbbc0703ff,
                          0x34deadbeef01c0ff,
                          0x8d37ab6fbbc0703f,
                          0x234deadbeef01c0f,
                          0x48d37ab6fbbc0703,
                          0x1234deadbeef01c0,
                          0x048d37ab6fbbc070,
                          0x81234deadbeef01c,
                          0xe048d37ab6fbbc07,
                          0x781234deadbeef01,
                          0x9e048d37ab6fbbc0,
                          0x6781234deadbeef0,
                          0x59e048d37ab6fbbc,
                          0x56781234deadbeef,
                          0x959e048d37ab6fbb,
                          0xa56781234deadbee,
                          0xe959e048d37ab6fb,
                          0xba56781234deadbe,
                          0xee959e048d37ab6f,
                          0xbba56781234deadb,
                          0xaee959e048d37ab6,
                          0xabba56781234dead};

  // unpadded stream (bits_per_char is 2 => no padding)
  uint16_t kmer_data[8] = {0xffee, 0x01c0, 0xbeef, 0xdead, 0x1234, 0x5678, 0xabba, 0x0000};

  // test with this data
  test_kmers<uint16_t>(kmer_data, kmer_ex);

  // NO padding, therefore we can test for different input types as well

  // 8 bit input
  test_kmers<uint8_t>(reinterpret_cast<uint8_t*>(kmer_data), kmer_ex);

  // 32 bit input
  test_kmers<uint32_t>(reinterpret_cast<uint32_t*>(kmer_data), kmer_ex);

  // 64 bit input
  test_kmers<uint64_t>(reinterpret_cast<uint64_t*>(kmer_data), kmer_ex);
}